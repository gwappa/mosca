
import sys, os, pprint, struct, json, zlib
from collections import OrderedDict
import numpy as np
from pyqtgraph.Qt import QtGui, QtCore
from . import models
from . import utils
from . import states
from . import devices
from . import param
from .utils import validate_integer

##
## I/O-related classes
##

BASETYPE = np.dtype('float')

StorageManager = None

def gen_config(nsamples, dtype="float64", byteorder='little'):
    """utility function that generates a dict object that contains channels and data shape info."""
    channels = OrderedDict()
    size     = 0
    for name, ch in devices.DeviceManager.current.channels.items():
        if ch.inuse == True:
            channels[name] = ch
            size += 1
    info = OrderedDict()
    info['channels'] = []
    for i, item in enumerate(channels.items()):
        name, ch = item
        chinfo = OrderedDict()
        chinfo['id']     = i
        chinfo['name']   = ch.label if len(ch.label) > 0 else ch.name
        chinfo['unit']   = ch.unit
        chinfo['range']  = ch.range
        chinfo['source'] = ch.name
        info['channels'].append(chinfo)
    info['data'] = OrderedDict()
    info['data']['datatype']  = dtype
    info['data']['byteorder'] = byteorder
    info['data']['shape']     = (nsamples, size)
    return info

class IODriverManager(models.BaseDriverManager):
    def prepare(self, save=True):
        if (save == True) and (self.current is not None):
            self.current.prepare()
        self.saved = save
        with states.StateManager.doneStorage as evt:
            evt.reset()

    def finalize(self):
        if self.saved == True:
            self.current.finalize()
        del self.saved
        with states.StateManager.doneStorage as evt:
            evt.set()

class BaseIODriver(models.DriverInterface):
    """Defines basic behaviors as an I/O driver."""
    acqno_changed = QtCore.pyqtSignal()

    def __init__(self, name, parent=None):
        super().__init__(parent)
        self.name       = name
        self._directory = os.getcwd()
        self._basename  = 'wave'
        self._acqno     = 1
        self._autoinc   = True
        self._configs   = []
        self._configs.append(param.ParameterController(label='Directory',
                                                        mode='dir',
                                                        getter=self.get_directory,
                                                        setter=self.set_directory))
        self._configs.append(param.ParameterController(label='Basename',
                                                        mode='str',
                                                        getter=self.get_basename,
                                                        setter=self.set_basename))
        self._configs.append(param.ParameterController(label='Acquisition number',
                                                        mode='int',
                                                        getter=self.get_acqno,
                                                        setter=self.set_acqno,
                                                        signal=self.acqno_changed))
        self._configs.append(param.ParameterController(label='Auto-increment',
                                                        mode='bool',
                                                        getter=self.get_autoinc,
                                                        setter=self.set_autoinc))

    def prepare(self):
        """prepares for the next acquisition."""
        pass

    def update(self, data):
        """a slot to update with newly acquired data."""
        pass

    def finalize(self):
        """finalizes the current acquisition"""
        pass

    def generate_configfile(self, info):
        """generates a JSON file containing information about channels and data shape.
        `info` as it can be generated by `gen_config()`."""
        filename = os.path.join(self.directory, "{0}_{1:03d}.cfg".format(self.basename, self.acqno))
        with open(filename, 'w') as output:
            json.dump(info, output, indent=4)
        print(f"[{self.name}] generated a config file: {filename}")

    def __getattr__(self, name):
        if name == 'directory':
            return self.get_directory()
        elif name == 'basename':
            return self.get_basename()
        elif name == 'acqno':
            return self.get_acqno()
        elif name == 'autoinc':
            return self.get_autoinc()
        else:
            raise AttributeError(name)

    def __setattr__(self, name, val):
        if name == 'directory':
            return self.set_directory(val)
        elif name == 'basename':
            return self.set_basename(val)
        elif name == 'acqno':
            return self.set_acqno(val)
        elif name == 'autoinc':
            return self.set_autoinc(val)
        else:
            super().__setattr__(name, val)

    def get_directory(self):
        return self._directory

    def get_basename(self):
        return self._basename

    def get_acqno(self):
        return self._acqno

    def get_autoinc(self):
        return self._autoinc

    def set_directory(self, val):
        self._directory = val

    def set_basename(self, val):
        self._basename = val

    def set_acqno(self, val):
        self._acqno = validate_integer(val, (-sys.maxsize, sys.maxsize), 'acquisition number')
        self.acqno_changed.emit()

    def set_autoinc(self, val):
        self._autoinc = val

    def configs(self):
        return self._configs

    def update_acqno(self):
        if self._autoinc == True:
            self.acqno += 1

class BareZLibDriver(BaseIODriver):
    """saves data in a bare array, through the Zlib-based compression."""

    def __init__(self, parent=None):
        super().__init__("Bare-zlib(beta)", parent=parent)

    def prepare(self):
        # FIXME: FROM HERE: in most cases the code is common with NumpyIODriver
        devices.DeviceManager.current.dataAvailable.connect(self.update)
        utils.ensure_directory(self.directory)
        self._nchan = len([ch for ch in devices.DeviceManager.current.channels.values() if ch.inuse == True])
        # self._info = dict(descr=BASETYPE.descr[0][1], fortran_order=False,
        #     shape=(sys.maxsize, self._nchan))
        self._size = 0
        self._scales = tuple(ch.scale for ch in devices.DeviceManager.current.channels.values() if ch.inuse == True)
        self._scales = np.array(self._scales).reshape((1,-1))
        # FIXME: TO HERE: code overlap

        self._zlib   = zlib.compressobj(level=1)

        # TODO: ask if we can overwrite file
        self._target = open(os.path.join(self.directory,
            "{0}_{1:03d}.zdat".format(self.basename, self.acqno)), 'wb')

    def update(self, data):
        # FIXME: the 2 lines below is exactly the same as in NumpyIODriver
        data = np.array(data, dtype=BASETYPE)*(self._scales)
        self._size += data.shape[0]

        self._target.write(self._zlib.compress( bytes(data.reshape((-1,), order='C') )))

    def finalize(self):
        # FIXME: the 2 lines below is exactly the same as in NumpyIODriver
        self.generate_configfile(gen_config(self._size))
        devices.DeviceManager.current.dataAvailable.disconnect(self.update)

        self._target.write(self._zlib.flush())
        del self._zlib
        self._target.close()
        self.update_acqno()


class NumpyIODriver(BaseIODriver):
    """For saving the acquired data in the numpy NPY format.

    for specification, please refer to: https://docs.scipy.org/doc/numpy/neps/npy-format.html"""

    _magic      = b'\x93NUMPY'
    _version    = b'\x01\x00'

    def __init__(self, parent=None):
        super().__init__('NumPy Binary', parent=parent)

    def prepare(self):
        devices.DeviceManager.current.dataAvailable.connect(self.update)
        utils.ensure_directory(self.directory)
        self._nchan = len([ch for ch in devices.DeviceManager.current.channels.values() if ch.inuse == True])
        self._info = dict(descr=BASETYPE.descr[0][1], fortran_order=False,
            shape=(sys.maxsize, self._nchan))
        self._size = 0
        self._scales = tuple(ch.scale for ch in devices.DeviceManager.current.channels.values() if ch.inuse == True)
        self._scales = np.array(self._scales).reshape((1,-1))

        self._headeroffset = len(self._magic) + len(self._version) + 2
        self._header = pprint.pformat(self._info).encode('utf-8')
        headerlen = len(self._header) + 1
        chunklen = self._headeroffset + headerlen
        r = chunklen % 16
        self._headerlen = headerlen if r == 0 else headerlen + (16 - r)

        # TODO: ask if we can overwrite file
        self._target = open(os.path.join(self.directory,
            "{0}_{1:03d}.npy".format(self.basename, self.acqno)), 'wb')
        self._target.write(self._magic)
        self._target.write(self._version)
        self._target.write(struct.pack('<H', self._headerlen))
        self._target.write(self._header)
        for i in range(self._headerlen - len(self._header) - 1):
            self._target.write(b' ')
        self._target.write(b'\n')

    def update(self, data):
        data = np.array(data, dtype=BASETYPE)*(self._scales)
        self._target.write(bytes(data.reshape((-1,), order='C')))
        self._size += data.shape[0]

    def finalize(self):
        devices.DeviceManager.current.dataAvailable.disconnect(self.update)
        self._info['shape'] = (self._size, self._nchan)
        self._header = pprint.pformat(self._info).encode('utf-8')
        self._target.seek(self._headeroffset)
        self._target.write(self._header)
        for i in range(self._headerlen - len(self._header) - 1):
            self._target.write(b' ')
        self._target.write(b'\n')
        self._target.close()
        self.generate_configfile(gen_config(self._size))
        self.update_acqno()

def setup(cfg):
    global StorageManager
    StorageManager = IODriverManager("I/O")
    StorageManager.load_drivers(cfg['storages'])
    # StorageManager.add_driver(NumpyIODriver())
